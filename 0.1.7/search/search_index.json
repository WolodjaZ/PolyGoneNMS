{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to PolyGoneNMS","text":"<p>PolyGoneNMS is an optimized library for performing Non-Maximum Suppression (NMS) on polygons in spatial data. It offers a flexible and efficient solution for handling large numbers of polygons in 1D, 2D, and 3D space.</p> <p>The library is designed to work with various NMS methods, such as Default, Soft, and Class Agnostic NMS, and supports multiple intersection methods, including Intersection over Union (IOU), Intersection over Self (IOS), and the Dice coefficient. PolyGoneNMS also supports distributed processing using Ray or Dask to speed up computations on large-scale datasets.</p> <p>The primary use case for PolyGoneNMS is in computer vision and GIS applications, where it can help to filter and cluster overlapping polygons and improve the overall performance of object detection and spatial analysis tasks.</p> <p>With an easy-to-use API and efficient implementation, PolyGoneNMS is the ideal choice for researchers, developers, and enthusiasts working on projects that involve processing large amounts of spatial polygon data.</p>"},{"location":"api_reference/","title":"API Reference","text":"<p>This page provides a comprehensive reference of the functions available in the PolyGoneNMS library.</p>"},{"location":"api_reference/#polygone_nms.nms","title":"<code>polygone_nms.nms</code>","text":""},{"location":"api_reference/#polygone_nms.nms.apply_distributed_polygon_nms","title":"<code>apply_distributed_polygon_nms(polygons, nms_method, intersection_method, threshold=0.5, sigma=0.5)</code>","text":"<p>Distributed version of <code>apply_polygon_nms</code>.</p> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>List[Tuple[Polygon, float, float]]</code> <p>List of polygons, where each polygon is a tuple of the polygon represented by shapely.geometry.Polygon object, the class label, and the confidence score.</p> required <code>nms_method</code> <code>str</code> <p>The NMS method to use, one of (\"Default\", \"Soft\", \"Class Agnostic\").</p> required <code>intersection_method</code> <code>Callable</code> <p>The method to compute intersections.</p> required <code>threshold</code> <code>float</code> <p>The threshold for the NMS method. Defaults to 0.5.</p> <code>0.5</code> <code>sigma</code> <code>float</code> <p>The sigma for the Soft NMS method. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of kept polygon indices.</p> Source code in <code>polygone_nms/nms.py</code> <pre><code>def apply_distributed_polygon_nms(\n    polygons: List[Tuple[Polygon, float, float]],\n    nms_method: str,\n    intersection_method: Callable,\n    threshold: float = 0.5,\n    sigma: float = 0.5,\n) -&gt; List[int]:\n\"\"\"\n    Distributed version of `apply_polygon_nms`.\n\n    Args:\n        polygons (List[Tuple[Polygon, float, float]]):\n            List of polygons, where each polygon is a tuple of the polygon\n            represented by shapely.geometry.Polygon object, the class label,\n            and the confidence score.\n        nms_method (str): The NMS method to use, one of\n            (\"Default\", \"Soft\", \"Class Agnostic\").\n        intersection_method (Callable): The method to compute intersections.\n        threshold (float, optional): The threshold for the NMS method. Defaults to 0.5.\n        sigma (float, optional): The sigma for the Soft NMS method. Defaults to 0.5.\n\n    Returns:\n        List[int]: A list of kept polygon indices.\n    \"\"\"\n    return apply_polygon_nms(\n        polygons, nms_method, intersection_method, threshold, sigma\n    )\n</code></pre>"},{"location":"api_reference/#polygone_nms.nms.apply_polygon_nms","title":"<code>apply_polygon_nms(polygons, nms_method, intersection_method, threshold=0.5, sigma=0.5)</code>","text":"<p>Apply Non-Maximum Suppression (NMS) to a list of predicted polygons.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the NMS method is invalid.</p> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>List[Tuple[Polygon, float, float]]</code> <p>List of polygons, where each polygon is a tuple of the polygon represented by shapely.geometry.Polygon object, the class label, and the confidence score.</p> required <code>nms_method</code> <code>str</code> <p>The NMS method to use, one of (\"Default\", \"Soft\", \"Class Agnostic\").</p> required <code>intersection_method</code> <code>Callable</code> <p>The method to compute intersections.</p> required <code>threshold</code> <code>float</code> <p>The threshold for the NMS method. Defaults to 0.5.</p> <code>0.5</code> <code>sigma</code> <code>float</code> <p>The sigma for the Soft NMS method. Defaults to 0.5.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of kept polygon indices.</p> Source code in <code>polygone_nms/nms.py</code> <pre><code>def apply_polygon_nms(\n    polygons: List[Tuple[Polygon, float, float]],\n    nms_method: str,\n    intersection_method: Callable,\n    threshold: float = 0.5,\n    sigma: float = 0.5,\n) -&gt; List[int]:\n\"\"\"\n    Apply Non-Maximum Suppression (NMS) to a list of predicted polygons.\n\n    Raises:\n        ValueError: If the NMS method is invalid.\n\n    Args:\n        polygons (List[Tuple[Polygon, float, float]]):\n            List of polygons, where each polygon is a tuple of the polygon\n            represented by shapely.geometry.Polygon object, the class label,\n            and the confidence score.\n        nms_method (str): The NMS method to use, one of\n            (\"Default\", \"Soft\", \"Class Agnostic\").\n        intersection_method (Callable): The method to compute intersections.\n        threshold (float, optional): The threshold for the NMS method. Defaults to 0.5.\n        sigma (float, optional): The sigma for the Soft NMS method. Defaults to 0.5.\n\n    Returns:\n        List[int]: A list of kept polygon indices.\n    \"\"\"\n    # List of kept polygons\n    kept_polygons = []\n\n    # Sort polygons by confidence score\n    confidences = np.array([poly[2] for poly in polygons])\n    sorted_indices = np.argsort(confidences)[::-1]\n\n    # Iterate over all sorted polygons by confidence score\n    while sorted_indices.size &gt; 0:\n        # Get the index of the current polygon and the respective polygon and label\n        i = sorted_indices[0]\n        current_polygon = polygons[i][0]\n        current_class = polygons[i][1]\n\n        # Add the current polygon to the NMS kept polygons list\n        kept_polygons.append(i)\n\n        # Calculate the intersection between the current polygon and\n        # all remaining polygons\n        intersections = [\n            intersection_method(current_polygon, polygons[j][0])\n            for j in sorted_indices[1:]\n        ]\n\n        # If the NMS method is \"Default\", \"Soft\" or \"Class Agnostic\"\n        if nms_method == \"Default\":\n            # Remove all remaining polygons that have an intersection with\n            # the current polygon greater than the threshold\n            remaining_indices = [\n                idx\n                for idx, intersection in zip(sorted_indices[1:], intersections)\n                if polygons[idx][1] != current_class or intersection &lt;= threshold\n            ]\n        elif nms_method == \"Soft\":\n            # Update the confidence scores of the remaining polygons\n            for j, intersection in zip(sorted_indices[1:], intersections):\n                # Calculate the weight for the current polygon equal to\n                # e^(-intersection^2 / sigma)\n                weight = np.exp(-(intersection**2) / sigma)\n                confidences[j] *= weight\n\n            # Discard polygons with confidence below the threshold\n            remaining_indices = [\n                idx for idx in sorted_indices[1:] if confidences[idx] &gt;= threshold\n            ]\n        elif nms_method == \"Class Agnostic\":\n            # Remove all remaining polygons that have an intersection with\n            # the current polygon greater than the threshold and\n            # have the same class label\n            remaining_indices = [\n                idx\n                for idx, intersection in zip(sorted_indices[1:], intersections)\n                if intersection &lt;= threshold\n            ]\n        else:\n            raise ValueError(\n                (\n                    f\"Invalid NMS method: {nms_method}. \"\n                    f\"Allowed methods are: {VALID_NMS_METHODS}\"\n                )\n            )\n\n        # Update the list of remaining polygon indices\n        sorted_indices = np.array(remaining_indices)\n\n    return kept_polygons\n</code></pre>"},{"location":"api_reference/#polygone_nms.nms.cluster_polygons","title":"<code>cluster_polygons(polygons, rtree_index)</code>","text":"<p>Cluster polygons into non-overlapping subregions with R-Tree. Used for distributed computing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import build_rtree, cluster_polygons\n&gt;&gt;&gt; polygons = [\n...     (Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), 0, 0.9),\n...     (Polygon([(2, 0), (3, 0), (3, 1), (2, 1)]), 0, 0.9),\n...     (Polygon([(4, 0), (5, 0), (5, 1), (4, 1)]), 0, 0.9),\n...     (Polygon([(0, 0.5), (1, 0.5), (1, 2), (0, 2)]), 0, 0.9),\n...     (Polygon([(2, 1), (3, 1), (3, 3), (2, 3)]), 0, 0.9),\n... ]\n&gt;&gt;&gt; rtree = build_rtree(polygons)\n&gt;&gt;&gt; clustered_polygons = cluster_polygons(polygons, rtree)\n&gt;&gt;&gt; assert len(clustered_polygons) == 3\n&gt;&gt;&gt; assert sorted(clustered_polygons[0]) == [0, 3]\n&gt;&gt;&gt; assert sorted(clustered_polygons[1]) == [1, 4]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>List[Tuple[Polygon, float, float]]</code> <p>List of polygons, where each polygon is a tuple of the polygon, the class label, and the confidence score.</p> required <code>rtree_index</code> <code>rtree.index.Index</code> <p>R-Tree index of the polygons.</p> required <p>Returns:</p> Type Description <code>List[List[Polygon]]</code> <p>List[List[Polygon]]: A list of clusters, where each cluster is a list of non-overlapping polygons.</p> Source code in <code>polygone_nms/nms.py</code> <pre><code>def cluster_polygons(\n    polygons: List[Tuple[Polygon, float, float]], rtree_index: rtree.index.Index\n) -&gt; List[List[Polygon]]:\n\"\"\"\n    Cluster polygons into non-overlapping subregions with R-Tree.\n    Used for distributed computing.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import build_rtree, cluster_polygons\n        &gt;&gt;&gt; polygons = [\n        ...     (Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), 0, 0.9),\n        ...     (Polygon([(2, 0), (3, 0), (3, 1), (2, 1)]), 0, 0.9),\n        ...     (Polygon([(4, 0), (5, 0), (5, 1), (4, 1)]), 0, 0.9),\n        ...     (Polygon([(0, 0.5), (1, 0.5), (1, 2), (0, 2)]), 0, 0.9),\n        ...     (Polygon([(2, 1), (3, 1), (3, 3), (2, 3)]), 0, 0.9),\n        ... ]\n        &gt;&gt;&gt; rtree = build_rtree(polygons)\n        &gt;&gt;&gt; clustered_polygons = cluster_polygons(polygons, rtree)\n        &gt;&gt;&gt; assert len(clustered_polygons) == 3\n        &gt;&gt;&gt; assert sorted(clustered_polygons[0]) == [0, 3]\n        &gt;&gt;&gt; assert sorted(clustered_polygons[1]) == [1, 4]\n\n    Args:\n        polygons (List[Tuple[Polygon, float, float]]): List of polygons,\n            where each polygon is a tuple of the polygon, the class label,\n            and the confidence score.\n        rtree_index (rtree.index.Index): R-Tree index of the polygons.\n\n    Returns:\n        List[List[Polygon]]:\n            A list of clusters,\n            where each cluster is a list of non-overlapping polygons.\n    \"\"\"\n    # Create a list of adjacent polygons for each polygon and\n    # a list of visited polygons\n    adj_list: List[List[int]] = [[] for _ in range(len(polygons))]\n    visited = [False] * len(polygons)\n\n    # Iterate over all polygons\n    for i, poly_tuple in enumerate(polygons):\n        # Get the polygon\n        poly = poly_tuple[0]\n        # Get all polygons that intersect with the current polygon\n        intersecting_polygons = list(rtree_index.intersection(poly.bounds))\n        # Remove the current polygon from the list of intersecting polygons\n        intersecting_polygons.remove(i)\n        # Update the adjacency list\n        adj_list[i] = intersecting_polygons\n\n    # Create a list of clusters\n    clusters = []\n    # Iterate over all polygons\n    for i in range(len(polygons)):\n        # If the current polygon has not been visited\n        if not visited[i]:\n            # Perform a depth-first search to find all connected components\n            # Due to RecursionError: maximum recursion depth exceeded\n            # connected_component = dfs_recursive(i, visited, adj_list)\n            connected_component = dfs_iterative(i, visited, adj_list)\n            # # Create a cluster from the connected component\n            # cluster = [polygons[j] for j in connected_component]\n            # # Append the cluster to the list of clusters\n            # Append the connected component (cluster) to the list of clusters\n            clusters.append(connected_component)\n\n    return clusters\n</code></pre>"},{"location":"api_reference/#polygone_nms.nms.nms","title":"<code>nms(input_data, distributed=None, nms_method='Default', intersection_method='IOU', threshold=0.5, sigma=0.5, **kwargs)</code>","text":"<p>Apply Non-Maximum Suppression (NMS) to a set of polygons. Method works with distributed computing for efficient processing and clustering.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from polygone.nms import nms\n&gt;&gt;&gt; input_data = np.array(\n... [\n...     [0.0, 0.0, 2.0, 0.0, 2.0, 2.0, 0.0, 2.0, 1.0, 0.9],\n...     [1.0, 0.0, 3.0, 0.0, 3.0, 2.0, 1.0, 2.0, 1.0, 0.8],\n...     [4.0, 4.0, 6.0, 4.0, 6.0, 6.0, 4.0, 6.0, 5.0, 0.95],\n...     [10.0, 10.0, 12.0, 10.0, 12.0, 12.0, 10.0, 12.0, 11.0, 0.9],\n...     [11.0, 10.0, 13.0, 10.0, 13.0, 12.0, 11.0, 12.0, 11.0, 0.8],\n...     [14.0, 14.0, 16.0, 14.0, 16.0, 16.0, 14.0, 16.0, 15.0, 0.95],\n... ])\n&gt;&gt;&gt; results = nms(input_data, None, \"Default\", \"IOU\", 0.3, 0.5)\n&gt;&gt;&gt; assert sorted(results) == [0, 2, 3, 5]\n</code></pre> <p>results = nms(input_data, None, nms_method, intersection_method, threshold, sigma) assert sorted(results) == expected</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Union[np.ndarray, Tuple[Polygon, float, float]]</code> <p>List of tuples of Polygon, class, score or numpy array of polygons. Each polygon in the numpy array is represented by a 1D array of n % 2 coordinates (x1, y1, x2, y2, .., x(n-1), y(n-1), class, score).</p> required <code>distributed</code> <code>Optional[str]</code> <p>The distributed computing method to use, one of (None, \"Ray\", \"Dask\").. Defaults to None.</p> <code>None</code> <code>nms_method</code> <code>str</code> <p>The NMS method to use, one of (\"Default\", \"Soft\", \"Class Agnostic\"). Defaults to \"Default\".</p> <code>'Default'</code> <code>intersection_method</code> <code>str</code> <p>The method to compute intersections, one of (\"IOU\", \"IOS\", \"Dice\", \"IOT\"). Defaults to \"IOU\".</p> <code>'IOU'</code> <code>threshold</code> <code>float</code> <p>The threshold for the NMS(intersection) method. Defaults to 0.5.</p> <code>0.5</code> <code>sigma</code> <code>float</code> <p>The sigma for the Soft NMS method. Defaults to 0.5.</p> <code>0.5</code> <code>**kwargs</code> <p>Additional arguments for the NMS method. Any keyword arguments for the distributed computing should be passed here.</p> <code>{}</code> <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: List of indices of the kept polygons.</p> Source code in <code>polygone_nms/nms.py</code> <pre><code>def nms(\n    input_data: Union[np.ndarray, Tuple[Polygon, float, float]],\n    distributed: Optional[str] = None,\n    nms_method: str = \"Default\",\n    intersection_method: str = \"IOU\",\n    threshold: float = 0.5,\n    sigma: float = 0.5,\n    **kwargs,\n) -&gt; List[int]:\n\"\"\"\n    Apply Non-Maximum Suppression (NMS) to a set of polygons.\n    Method works with distributed computing for efficient processing and clustering.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from polygone.nms import nms\n        &gt;&gt;&gt; input_data = np.array(\n        ... [\n        ...     [0.0, 0.0, 2.0, 0.0, 2.0, 2.0, 0.0, 2.0, 1.0, 0.9],\n        ...     [1.0, 0.0, 3.0, 0.0, 3.0, 2.0, 1.0, 2.0, 1.0, 0.8],\n        ...     [4.0, 4.0, 6.0, 4.0, 6.0, 6.0, 4.0, 6.0, 5.0, 0.95],\n        ...     [10.0, 10.0, 12.0, 10.0, 12.0, 12.0, 10.0, 12.0, 11.0, 0.9],\n        ...     [11.0, 10.0, 13.0, 10.0, 13.0, 12.0, 11.0, 12.0, 11.0, 0.8],\n        ...     [14.0, 14.0, 16.0, 14.0, 16.0, 16.0, 14.0, 16.0, 15.0, 0.95],\n        ... ])\n        &gt;&gt;&gt; results = nms(input_data, None, \"Default\", \"IOU\", 0.3, 0.5)\n        &gt;&gt;&gt; assert sorted(results) == [0, 2, 3, 5]\n\n    results = nms(input_data, None, nms_method, intersection_method, threshold, sigma)\n    assert sorted(results) == expected\n\n    Args:\n        input_data (Union[np.ndarray, Tuple[Polygon, float, float]]):\n            List of tuples of Polygon, class, score or numpy array of polygons.\n            Each polygon in the numpy array is represented by a 1D array of n % 2\n            coordinates (x1, y1, x2, y2, .., x(n-1), y(n-1), class, score).\n        distributed (Optional[str], optional):\n            The distributed computing method to use,\n            one of (None, \"Ray\", \"Dask\").. Defaults to None.\n        nms_method (str, optional):\n            The NMS method to use, one of (\"Default\", \"Soft\", \"Class Agnostic\").\n            Defaults to \"Default\".\n        intersection_method (str, optional):\n            The method to compute intersections, one of (\"IOU\", \"IOS\", \"Dice\", \"IOT\").\n            Defaults to \"IOU\".\n        threshold (float, optional):\n            The threshold for the NMS(intersection) method. Defaults to 0.5.\n        sigma (float, optional):\n            The sigma for the Soft NMS method. Defaults to 0.5.\n        **kwargs: Additional arguments for the NMS method.\n            Any keyword arguments for the distributed computing should be passed here.\n\n    Returns:\n        List[int]: List of indices of the kept polygons.\n    \"\"\"\n    # Check if the input data is a list of polygons or a 2D NumPy array\n    polygons = []\n    if isinstance(input_data, list):\n        if len(input_data) == 0:\n            return []\n        elif isinstance(input_data[0], tuple):\n            polygons = input_data\n        else:\n            input_data = np.array(input_data)\n    elif not isinstance(input_data, np.ndarray):\n        raise ValueError(\n            \"Invalid input data type. Expected a list of polygons or a 2D NumPy array.\"\n        )\n\n    # Check distributed computing method\n    if distributed is not None:\n        if distributed not in VALID_DISTRIBUTED_METHODS:\n            raise ValueError(\n                (\n                    f\"Invalid distributed computing method: {distributed}. \"\n                    f\"Allowed methods are: {VALID_DISTRIBUTED_METHODS}\"\n                )\n            )\n\n    # Check NMS method\n    if nms_method not in VALID_NMS_METHODS:\n        raise ValueError(\n            (\n                f\"Invalid NMS method: {nms_method}. \"\n                f\"Allowed methods are: {VALID_NMS_METHODS}\"\n            )\n        )\n\n    # Check intersection method\n    if intersection_method not in list(INTERSECTION_METHODS.keys()):\n        raise ValueError(\n            (\n                f\"Invalid intersection method: {intersection_method}. \"\n                f\"Allowed methods are: {list(INTERSECTION_METHODS.keys())}\"\n            )\n        )\n\n    # Get the intersection function\n    intersection_func = INTERSECTION_METHODS[intersection_method]\n\n    # Convert input data to Shapely Polygons and store class and confidence\n    if len(polygons) == 0:\n        for row in input_data:\n            polygon_coords = row[:-2]\n            class_label = row[-2]\n            confidence = row[-1]\n            polygon = create_polygon(polygon_coords)\n            polygons.append((polygon, class_label, confidence))\n\n    # Build R-Tree index\n    rtree = build_rtree(polygons)\n\n    # Cluster polygons into non-overlapping subregions\n    clusters = cluster_polygons(polygons, rtree)\n    polygon_clusters = [[polygons[idx] for idx in cluster] for cluster in clusters]\n\n    # Apply NMS to the clustered polygons\n    if distributed == \"Ray\":\n        # Import Ray\n        import ray\n\n        # Check if Ray is initialized\n        if ray.is_initialized():\n            initialize_ray = False\n        else:\n            initialize_ray = True\n            ray.init()  # Initialize Ray\n\n        # Scatter the polygon clusters to the Ray cluster\n        polygon_futures = [\n            ray.put(polygon_cluster) for polygon_cluster in polygon_clusters\n        ]\n\n        # Apply NMS to each cluster\n        nms_polygons_futures = [\n            ray.remote(apply_distributed_polygon_nms).remote(\n                polygon_future, nms_method, intersection_func, threshold, sigma\n            )\n            for polygon_future in polygon_futures\n        ]\n        nms_polygons = ray.get(nms_polygons_futures)\n\n        # Shutdown Ray if it was initialized in this function\n        if initialize_ray:\n            ray.shutdown()  # Shutdown Ray\n    elif distributed == \"Dask\":\n        # Use an existing Dask client if provided, or create a new one\n        client = kwargs.get(\"client\", None)\n        if client is None:\n            from dask.distributed import Client\n\n            initialize_dask = True\n            client = Client()\n        else:\n            initialize_dask = False\n\n        # Scatter the polygon clusters to the Dask cluster\n        polygon_futures = client.scatter(polygon_clusters)\n\n        # Apply NMS to each cluster and gather the results\n        nms_polygon_futures = client.map(\n            functools.partial(\n                apply_distributed_polygon_nms,\n                nms_method=nms_method,\n                intersection_method=intersection_func,\n                threshold=threshold,\n                sigma=sigma,\n            ),\n            polygon_futures,\n        )\n        nms_polygons = client.gather(nms_polygon_futures)\n        # Shutdown Dask if it was initialized in this function\n        if initialize_dask:\n            client.close()  # Shutdown Dask\n    else:\n        # Apply NMS to each cluster\n        nms_polygons = [\n            apply_distributed_polygon_nms(\n                polygon_cluster, nms_method, intersection_func, threshold, sigma\n            )\n            for polygon_cluster in polygon_clusters\n        ]\n\n    # Combine the kept polygon indices from each cluster and\n    # get the keep indices from each cluster\n    keep_indices = []\n    for cluster, cluster_nms in zip(clusters, nms_polygons):\n        for idx in cluster_nms:\n            keep_indices.append(cluster[idx])\n\n    return keep_indices\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils","title":"<code>polygone_nms.utils</code>","text":""},{"location":"api_reference/#polygone_nms.utils.bbox_to_polygon_array","title":"<code>bbox_to_polygon_array(coords)</code>","text":"<p>Convert bbox [xmin, ymin, xmax, ymax] to polygon format [xmin, ymin, xmax, ymin, xmax, ymax, xmin, ymax]</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>np.ndarray</code> <p>bbox coordinates</p> required <p>Returns:</p> Type Description <code>np.ndarray</code> <p>np.ndarray: polygon coordinates</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def bbox_to_polygon_array(coords: np.ndarray) -&gt; np.ndarray:\n\"\"\"\n    Convert bbox [xmin, ymin, xmax, ymax] to polygon format\n    [xmin, ymin, xmax, ymin, xmax, ymax, xmin, ymax]\n\n    Args:\n        coords (np.ndarray): bbox coordinates\n    Returns:\n        np.ndarray: polygon coordinates\n    \"\"\"\n    return np.array(\n        [\n            coords[0],\n            coords[1],\n            coords[2],\n            coords[1],\n            coords[2],\n            coords[3],\n            coords[0],\n            coords[3],\n        ]\n    )\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.build_rtree","title":"<code>build_rtree(polygons)</code>","text":"<p>Build an R-tree index from a list of tuples having polygon, class and confidence.</p> <p>The R-tree index is used to perform spatial queries on the input polygons. The input polygons are represented as Shapely Polygons.</p> <p>The R-tree index is built using the rtree library. More information about the R-tree library can be found here: https://pypi.org/project/rtree/</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import build_rtree\n&gt;&gt;&gt; p1 = (Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), 0, 0.9)\n&gt;&gt;&gt; p2 = (Polygon([(2, 0), (3, 0), (3, 1), (2, 1)]), 1, 0.8)\n&gt;&gt;&gt; p3 = (Polygon([(1, 2), (2, 2), (2, 3), (1, 3)]), 1, 0.7)\n&gt;&gt;&gt; rtree_index = build_rtree([p1, p2, p3])\n&gt;&gt;&gt; query_bounds = (0.5, 0.5, 1.5, 1.5)\n&gt;&gt;&gt; list(rtree_index.intersection(query_bounds))\n[0]\n&gt;&gt;&gt; query_bounds = (1.5, 1.5, 2.5, 2.5)\n&gt;&gt;&gt; list(rtree_index.intersection(query_bounds))\n[2]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>polygons</code> <code>List[Tuple[Polygon, float, float]]</code> <p>A list of tuples having polygon, class and confidence.</p> required <p>Returns:</p> Type Description <code>rtree.index.Index</code> <p>rtree.index.Index: An R-tree index containing the input polygons.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def build_rtree(polygons: List[Tuple[Polygon, float, float]]) -&gt; rtree.index.Index:\n\"\"\"\n    Build an R-tree index from a list of tuples having polygon, class and confidence.\n\n    The R-tree index is used to perform spatial queries on the input polygons.\n    The input polygons are represented as Shapely Polygons.\n\n    The R-tree index is built using the rtree library.\n    More information about the R-tree library can be found here:\n    https://pypi.org/project/rtree/\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import build_rtree\n        &gt;&gt;&gt; p1 = (Polygon([(0, 0), (1, 0), (1, 1), (0, 1)]), 0, 0.9)\n        &gt;&gt;&gt; p2 = (Polygon([(2, 0), (3, 0), (3, 1), (2, 1)]), 1, 0.8)\n        &gt;&gt;&gt; p3 = (Polygon([(1, 2), (2, 2), (2, 3), (1, 3)]), 1, 0.7)\n        &gt;&gt;&gt; rtree_index = build_rtree([p1, p2, p3])\n        &gt;&gt;&gt; query_bounds = (0.5, 0.5, 1.5, 1.5)\n        &gt;&gt;&gt; list(rtree_index.intersection(query_bounds))\n        [0]\n        &gt;&gt;&gt; query_bounds = (1.5, 1.5, 2.5, 2.5)\n        &gt;&gt;&gt; list(rtree_index.intersection(query_bounds))\n        [2]\n\n    Args:\n        polygons (List[Tuple[Polygon, float, float]]):\n            A list of tuples having polygon, class and confidence.\n\n    Returns:\n        rtree.index.Index: An R-tree index containing the input polygons.\n    \"\"\"\n    # Create an R-tree index\n    rtree_idx = index.Index()\n\n    # Iterate over the polygons and add them to the R-tree index\n    for idx, row in enumerate(polygons):\n        # Retrieve polygon, class, and confidence\n        polygon, cls, conf = row\n\n        # Calculate the bounding box of the polygon\n        bbox = polygon.bounds  # Returns (minx, miny, maxx, maxy)\n\n        # Insert the bounding box into the R-tree\n        rtree_idx.insert(\n            idx, bbox, obj={\"polygon\": polygon, \"class\": cls, \"confidence\": conf}\n        )\n\n    return rtree_idx\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.create_polygon","title":"<code>create_polygon(coords, none_value=-1.0)</code>","text":"<p>Create a Shapely Polygon from a numpy array row of coordinates. If the number of coordinates is odd, an error is raised. If any of the coordinates is of <code>none_value</code>, it is ignored.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from polygone_nms.utils import create_polygon\n&gt;&gt;&gt; coords = np.array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0])\n&gt;&gt;&gt; poly = create_polygon(coords)\n&gt;&gt;&gt; poly.is_valid\nTrue\n&gt;&gt;&gt; poly.area\n1.0\n&gt;&gt;&gt; coords = np.array([2.0, 0.0, 3.0, 0.0, 3.0, 1.0, 2.0, 1.0, 2.0, 0.0])\n&gt;&gt;&gt; poly = create_polygon(coords)\n&gt;&gt;&gt; poly.is_valid\nTrue\n&gt;&gt;&gt; poly.area\n1.0\n&gt;&gt;&gt; coords = np.array([1.0, 2.0, 2.0, 2.0, 2.0, 3.0, -1.0, -1.0])\n&gt;&gt;&gt; poly = create_polygon(coords)\n&gt;&gt;&gt; poly.is_valid\nTrue\n&gt;&gt;&gt; poly.area\n0.5\n&gt;&gt;&gt; coords = np.array([1.0, 2.0, 2.0, 2.0, 2.0, 3.0, -1.0, -1.0, 1.0, 2.0])\n&gt;&gt;&gt; poly = create_polygon(coords)\nTraceback (most recent call last):\n...\nValueError: The number of coordinates must be even.\n</code></pre> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the number of coordinates is odd.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>np.ndarray</code> <p>A numpy array of coordinates for a shapely.geometry.Polygon.</p> required <code>none_value</code> <code>float</code> <p>A value to be ignored. Defaults to -1.0.</p> <code>-1.0</code> <p>Returns:</p> Name Type Description <code>Polygon</code> <code>Polygon</code> <p>A Shapely Polygon.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def create_polygon(coords: np.ndarray, none_value: float = -1.0) -&gt; Polygon:\n\"\"\"\n    Create a Shapely Polygon from a numpy array row of coordinates.\n    If the number of coordinates is odd, an error is raised.\n    If any of the coordinates is of `none_value`, it is ignored.\n\n    Examples:\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; from polygone_nms.utils import create_polygon\n        &gt;&gt;&gt; coords = np.array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0])\n        &gt;&gt;&gt; poly = create_polygon(coords)\n        &gt;&gt;&gt; poly.is_valid\n        True\n        &gt;&gt;&gt; poly.area\n        1.0\n        &gt;&gt;&gt; coords = np.array([2.0, 0.0, 3.0, 0.0, 3.0, 1.0, 2.0, 1.0, 2.0, 0.0])\n        &gt;&gt;&gt; poly = create_polygon(coords)\n        &gt;&gt;&gt; poly.is_valid\n        True\n        &gt;&gt;&gt; poly.area\n        1.0\n        &gt;&gt;&gt; coords = np.array([1.0, 2.0, 2.0, 2.0, 2.0, 3.0, -1.0, -1.0])\n        &gt;&gt;&gt; poly = create_polygon(coords)\n        &gt;&gt;&gt; poly.is_valid\n        True\n        &gt;&gt;&gt; poly.area\n        0.5\n        &gt;&gt;&gt; coords = np.array([1.0, 2.0, 2.0, 2.0, 2.0, 3.0, -1.0, -1.0, 1.0, 2.0])\n        &gt;&gt;&gt; poly = create_polygon(coords)\n        Traceback (most recent call last):\n            ...\n        ValueError: The number of coordinates must be even.\n\n    Raises:\n        ValueError: If the number of coordinates is odd.\n\n    Args:\n        coords (np.ndarray):\n            A numpy array of coordinates for a shapely.geometry.Polygon.\n        none_value (float, optional): A value to be ignored. Defaults to -1.0.\n\n    Returns:\n        Polygon: A Shapely Polygon.\n    \"\"\"\n    assert len(coords.shape) == 1, \"The coordinates must be a 1D array.\"\n    if coords.shape[0] % 2 != 0:\n        raise ValueError(\"The number of coordinates must be even.\")\n    assert coords.shape[0] % 2 == 0, \"The number of coordinates must be even.\"\n\n    if coords.shape[0] == 4:\n        coords = bbox_to_polygon_array(coords)\n\n    points = [\n        (coords[i], coords[i + 1])\n        for i in range(0, len(coords), 2)\n        if coords[i] != none_value and coords[i + 1] != none_value\n    ]\n    return Polygon(points)\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.dfs_iterative","title":"<code>dfs_iterative(node, visited, adj_list)</code>","text":"<p>Perform a depth-first search on an adjacency list (graph) in a iterative manner.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from polygone_nms.utils import dfs\n&gt;&gt;&gt; adj_list = [[1], [0, 2, 3], [1], [1]]\n&gt;&gt;&gt; visited = [False] * len(adj_list)\n&gt;&gt;&gt; dfs(0, visited, adj_list)\n[0, 1, 2, 3]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>int</code> <p>The starting node for the DFS traversal.</p> required <code>visited</code> <code>List[bool]</code> <p>list of booleans indicating whether a node has been visited.</p> required <code>adj_list</code> <code>List[List[int]]</code> <p>The adjacency list representing the graph.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of nodes in the connected component found by the DFS traversal.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def dfs_iterative(\n    node: int, visited: List[bool], adj_list: List[List[int]]\n) -&gt; List[int]:\n\"\"\"\n    Perform a depth-first search on an adjacency list (graph) in a iterative manner.\n\n    Examples:\n        &gt;&gt;&gt; from polygone_nms.utils import dfs\n        &gt;&gt;&gt; adj_list = [[1], [0, 2, 3], [1], [1]]\n        &gt;&gt;&gt; visited = [False] * len(adj_list)\n        &gt;&gt;&gt; dfs(0, visited, adj_list)\n        [0, 1, 2, 3]\n\n    Args:\n        node (int): The starting node for the DFS traversal.\n        visited (List[bool]):\n            list of booleans indicating whether a node has been visited.\n        adj_list (List[List[int]]): The adjacency list representing the graph.\n\n    Returns:\n        List[int]:\n            A list of nodes in the connected component found by the DFS traversal.\n    \"\"\"\n    # Create a list to store the connected component\n    connected_component = []\n\n    # Create a stack\n    stack = [node]\n\n    # Iterate over the stack\n    while stack:\n        # Pop the last element from the stack\n        curr_node = stack.pop()\n        # If the node has not been visited, mark it as visited and\n        # add it to the connected component\n        if not visited[curr_node]:\n            visited[curr_node] = True\n            connected_component.append(curr_node)\n            # Add the neighbors of the current node to the stack if\n            # they have not been visited\n            stack.extend(\n                reversed(\n                    [\n                        neighbor\n                        for neighbor in adj_list[curr_node]\n                        if not visited[neighbor]\n                    ]\n                )\n            )\n\n    return connected_component\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.dfs_recursive","title":"<code>dfs_recursive(node, visited, adj_list)</code>","text":"<p>Perform a depth-first search on an adjacency list (graph) in a recursive manner.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from polygone_nms.utils import dfs\n&gt;&gt;&gt; adj_list = [[1], [0, 2, 3], [1], [1]]\n&gt;&gt;&gt; visited = [False] * len(adj_list)\n&gt;&gt;&gt; dfs(0, visited, adj_list)\n[0, 1, 2, 3]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>int</code> <p>The starting node for the DFS traversal.</p> required <code>visited</code> <code>List[bool]</code> <p>list of booleans indicating whether a node has been visited.</p> required <code>adj_list</code> <code>List[List[int]]</code> <p>The adjacency list representing the graph.</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>List[int]: A list of nodes in the connected component found by the DFS traversal.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def dfs_recursive(\n    node: int, visited: List[bool], adj_list: List[List[int]]\n) -&gt; List[int]:\n\"\"\"\n    Perform a depth-first search on an adjacency list (graph) in a recursive manner.\n\n    Examples:\n        &gt;&gt;&gt; from polygone_nms.utils import dfs\n        &gt;&gt;&gt; adj_list = [[1], [0, 2, 3], [1], [1]]\n        &gt;&gt;&gt; visited = [False] * len(adj_list)\n        &gt;&gt;&gt; dfs(0, visited, adj_list)\n        [0, 1, 2, 3]\n\n    Args:\n        node (int): The starting node for the DFS traversal.\n        visited (List[bool]):\n            list of booleans indicating whether a node has been visited.\n        adj_list (List[List[int]]): The adjacency list representing the graph.\n\n    Returns:\n        List[int]:\n            A list of nodes in the connected component found by the DFS traversal.\n    \"\"\"\n    # Mark the node as visited\n    visited[node] = True\n\n    # Add the node to the list\n    connected_component = [node]\n\n    # Iterate over the neighbors of the node\n    for neighbor in adj_list[node]:\n        # If the neighbor has not been visited, perform a depth-first search on it\n        if not visited[neighbor]:\n            # Extend the connected component with the connected component\n            # found by the DFS traversal pf the neighbor\n            connected_component.extend(dfs_recursive(neighbor, visited, adj_list))\n\n    return connected_component\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.dice","title":"<code>dice(poly1, poly2)</code>","text":"<p>Compute the dice coefficient between two Shapely Polygons.</p> <p>The Dice coefficient is a similarity measure used in image segmentation tasks, particularly for comparing binary segmentation masks. It is defined as the ratio of twice the area of intersection between the predicted and ground truth masks to the sum of their areas.</p> <p>Dice=(2 * Area of Intersection) / (Area of First Polygon + Area of Second Polygon)</p> <p>The Dice coefficient ranges from 0 (no overlap) to 1 (perfect overlap).</p> Notes <p>It is more sensitive to the size of the regions than IoU and is particularly useful for evaluating the performance of segmentation algorithms in cases where the regions of interest have varying sizes and shapes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import dice\n&gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n&gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n&gt;&gt;&gt; dice(poly1, poly2)\n0.5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>poly1</code> <code>Polygon</code> <p>The first polygon represented by a shapely.geometry.Polygon object.</p> required <code>poly2</code> <code>Polygon</code> <p>The second polygon represented by a shapely.geometry.Polygon object.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Dice value between the two Shapely Polygons.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def dice(poly1: Polygon, poly2: Polygon) -&gt; float:\n\"\"\"\n    Compute the dice coefficient between two Shapely Polygons.\n\n    The Dice coefficient is a similarity measure used in image segmentation tasks,\n    particularly for comparing binary segmentation masks.\n    It is defined as the ratio of twice the area of intersection\n    between the predicted and ground truth masks to the sum of their areas.\n\n    Dice=(2 * Area of Intersection) / (Area of First Polygon + Area of Second Polygon)\n\n    The Dice coefficient ranges from 0 (no overlap) to 1 (perfect overlap).\n\n    Notes:\n        It is more sensitive to the size of the regions than IoU and is\n        particularly useful for evaluating the performance of segmentation algorithms\n        in cases where the regions of interest have varying sizes and shapes.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import dice\n        &gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n        &gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n        &gt;&gt;&gt; dice(poly1, poly2)\n        0.5\n\n    Args:\n        poly1 (Polygon):\n            The first polygon represented by a shapely.geometry.Polygon object.\n        poly2 (Polygon):\n            The second polygon represented by a shapely.geometry.Polygon object.\n    Returns:\n        float: The Dice value between the two Shapely Polygons.\n    \"\"\"\n    # Calculate the intersection\n    intersection = poly1.intersection(poly2)\n\n    # Calculate the sum area\n    sum_area = poly1.area + poly2.area\n\n    # If the sum area is 0, than Polygons are empty in future are information #TODO\n    if sum_area == 0:\n        return 0\n\n    # Calculate the Dice coefficient\n    return 2 * intersection.area / sum_area\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.ios","title":"<code>ios(poly1, poly2)</code>","text":"<p>Compute the intersection over smaller (IoS) between two Shapely Polygons.</p> <p>IoS is another overlap metric that measures the ratio of the area of intersection between two regions to the area of the smaller region.</p> <p>IoS = (Area of Intersection) / (Area of the Smaller Region)</p> <p>An IoU score of 1 means that the predicted and ground truth regions perfectly overlap, while a score of 0 means that there's no overlap at all.</p> Notes <p>Unlike IoU, IoS is more sensitive to the size of the regions being compared. In certain scenarios, using IoS can help to better evaluate the quality of detections, especially when dealing with objects of varying sizes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import ios\n&gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n&gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n&gt;&gt;&gt; ios(poly1, poly2)\n0.5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>poly1</code> <code>Polygon</code> <p>The first polygon represented by a shapely.geometry.Polygon object.</p> required <code>poly2</code> <code>Polygon</code> <p>The second polygon represented by a shapely.geometry.Polygon object.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The IoS value between the two Shapely Polygons.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def ios(poly1: Polygon, poly2: Polygon) -&gt; float:\n\"\"\"\n    Compute the intersection over smaller (IoS) between two Shapely Polygons.\n\n    IoS is another overlap metric that measures the ratio of the area of\n    intersection between two regions to the area of the smaller region.\n\n    IoS = (Area of Intersection) / (Area of the Smaller Region)\n\n    An IoU score of 1 means that the predicted and ground truth regions\n    perfectly overlap, while a score of 0 means that there's no overlap at all.\n\n    Notes:\n        Unlike IoU, IoS is more sensitive to the size of the regions being compared.\n        In certain scenarios, using IoS can help to better evaluate the quality\n        of detections, especially when dealing with objects of varying sizes.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import ios\n        &gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n        &gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n        &gt;&gt;&gt; ios(poly1, poly2)\n        0.5\n\n    Args:\n        poly1 (Polygon):\n            The first polygon represented by a shapely.geometry.Polygon object.\n        poly2 (Polygon):\n            The second polygon represented by a shapely.geometry.Polygon object.\n    Returns:\n        float: The IoS value between the two Shapely Polygons.\n    \"\"\"\n    # Calculate the intersection area\n    intersection_area = poly1.intersection(poly2).area\n\n    # Calculate the area of the smaller polygon\n    smaller_area = min(poly1.area, poly2.area)\n\n    # If the smaller area is 0, return 0\n    if smaller_area == 0:\n        return 0\n\n    # Calculate the IoS\n    return intersection_area / smaller_area\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.iot","title":"<code>iot(target, compared)</code>","text":"<p>Compute the intersection over target (IoT) between two Shapely Polygons.</p> <p>IoT is another overlap metric that measures the ratio of the area of intersection between the Target and Compared regions to the area of the Target region.</p> <p>IoT = (Area of Intersection) / (Area of the Target Region)</p> <p>An IoT score of 1 means that the compared region perfectly overlaps the target region, while a score of 0 means that there's no overlap at all.</p> Notes <p>This is a testing metrics designed for NMS algorithm. My intuition is that if used with NMS algorithm it can result in a better performance.</p> <p>the predicted and ground truth regions perfectly overlap, while a score of 0 means that there's no overlap at all.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import iot\n&gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n&gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n&gt;&gt;&gt; iot(poly1, poly2)\n0.5\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Polygon</code> <p>The target polygon represented by a shapely.geometry.Polygon object.</p> required <code>compared</code> <code>Polygon</code> <p>The second polygon represented by a shapely.geometry.Polygon object.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The IOT value between target and compared Shapely Polygons.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def iot(target: Polygon, compared: Polygon) -&gt; float:\n\"\"\"\n    Compute the intersection over target (IoT) between two Shapely Polygons.\n\n    IoT is another overlap metric that measures the ratio of the area of\n    intersection between the Target and Compared regions to the area of\n    the Target region.\n\n    IoT = (Area of Intersection) / (Area of the Target Region)\n\n    An IoT score of 1 means that the compared region perfectly overlaps\n    the target region, while a score of 0 means that there's no overlap at all.\n\n    Notes:\n        This is a testing metrics designed for NMS algorithm.\n        My intuition is that if used\n        with NMS algorithm it can result in a better performance.\n\n    the predicted and ground truth regions perfectly overlap,\n    while a score of 0 means that there's no overlap at all.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import iot\n        &gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n        &gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n        &gt;&gt;&gt; iot(poly1, poly2)\n        0.5\n\n    Args:\n        target (Polygon):\n            The target polygon represented by a shapely.geometry.Polygon object.\n        compared (Polygon):\n            The second polygon represented by a shapely.geometry.Polygon object.\n\n    Returns:\n        float: The IOT value between target and compared Shapely Polygons.\n    \"\"\"\n    # Calculate the intersection area\n    intersection_area = target.intersection(compared).area\n\n    # Calculate the area of the target polygon\n    target_area = target.area\n\n    # If the target area is 0, than Polygons are empty in future are information #TODO\n    if target_area == 0:\n        return 0\n\n    # Calculate the IoT\n    return intersection_area / target_area\n</code></pre>"},{"location":"api_reference/#polygone_nms.utils.iou","title":"<code>iou(poly1, poly2)</code>","text":"<p>Compute the intersection over union (IoU) between two Shapely Polygons.</p> <p>IoU is a popular metric for evaluating the quality of object detections and segmentations. It measures the ratio of the area of overlap between two regions (e.g., predicted and ground truth bounding boxes) to the area of their union.</p> <p>IOU = Area of intersection / Area of union    ~= Area of intersection / (Area of poly1 + Area of poly2 - Area of intersection)</p> <p>An IoU score of 1 means that the predicted and ground truth regions perfectly overlap, while a score of 0 means that there's no overlap at all.</p> Notes <p>In object detection and segmentation tasks, a higher IoU threshold indicates a stricter evaluation criterion.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shapely.geometry import Polygon\n&gt;&gt;&gt; from polygone_nms.utils import iou\n&gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n&gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n&gt;&gt;&gt; iou(poly1, poly2)\n0.3333333333333333\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>poly1</code> <code>Polygon</code> <p>The first polygon represented by a shapely.geometry.Polygon object.</p> required <code>poly2</code> <code>Polygon</code> <p>The second polygon represented by a shapely.geometry.Polygon object.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The IoU value between the two Shapely Polygons.</p> Source code in <code>polygone_nms/utils.py</code> <pre><code>def iou(poly1: Polygon, poly2: Polygon) -&gt; float:\n\"\"\"\n    Compute the intersection over union (IoU) between two Shapely Polygons.\n\n    IoU is a popular metric for evaluating the quality of\n    object detections and segmentations. It measures the ratio of the area of overlap\n    between two regions (e.g., predicted and ground truth bounding boxes)\n    to the area of their union.\n\n    IOU = Area of intersection / Area of union\n       ~= Area of intersection / (Area of poly1 + Area of poly2 - Area of intersection)\n\n    An IoU score of 1 means that the predicted and ground truth regions\n    perfectly overlap, while a score of 0 means that there's no overlap at all.\n\n    Notes:\n        In object detection and segmentation tasks,\n        a higher IoU threshold indicates a stricter evaluation criterion.\n\n    Examples:\n        &gt;&gt;&gt; from shapely.geometry import Polygon\n        &gt;&gt;&gt; from polygone_nms.utils import iou\n        &gt;&gt;&gt; poly1 = Polygon([(0, 0), (1, 0), (1, 1), (0, 1)])\n        &gt;&gt;&gt; poly2 = Polygon([(0.5, 0), (1.5, 0), (1.5, 1), (0.5, 1)])\n        &gt;&gt;&gt; iou(poly1, poly2)\n        0.3333333333333333\n\n    Args:\n        poly1 (Polygon):\n            The first polygon represented by a shapely.geometry.Polygon object.\n        poly2 (Polygon):\n            The second polygon represented by a shapely.geometry.Polygon object.\n\n    Returns:\n        float: The IoU value between the two Shapely Polygons.\n    \"\"\"\n    # Calculate the intersection area\n    intersection_area = poly1.intersection(poly2).area\n\n    # Calculate the union\n    union_area = poly1.area + poly2.area - intersection_area\n    # union_area = poly1.union(poly2).area tested and it's slower\n\n    # If the union area is 0, return 0\n    if union_area == 0:\n        return 0\n\n    # Calculate the IoU\n    return intersection_area / union_area\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p>"},{"location":"changelog/#017","title":"[0.1.7]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>updated docs with correct import of NMS algorithm.</li> <li>updated <code>README.md</code> with correct import of NMS algorithm.</li> <li>reimplemented <code>utils</code> to handle <code>ZeroDivisionError</code> errors.</li> </ul>"},{"location":"changelog/#016","title":"[0.1.6]","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Working Pypi upload structure</li> </ul>"},{"location":"changelog/#015","title":"[0.1.5]","text":"<p>PyPi tests</p>"},{"location":"changelog/#014","title":"[0.1.4]","text":"<p>PyPi tests</p>"},{"location":"changelog/#013","title":"[0.1.3]","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Pypi Publish Github Actions modified</li> </ul>"},{"location":"changelog/#012","title":"[0.1.2]","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>CI/CD adjustments for the project in github actions.</li> <li>docs references repair.</li> <li>docs doc-strings examples corrected</li> <li>docs creation github action repair.</li> </ul>"},{"location":"changelog/#011","title":"[0.1.1]","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>PolyGoneNMS library for efficient and distributed polygon Non-Maximum Suppression (NMS).</li> <li>Support for different NMS methods: Default, Soft, and Class Agnostic.</li> <li>Support for various intersection methods: IOU, IOS, and Dice.</li> <li>R-tree data structure for efficient spatial indexing and querying.</li> <li>Distributed processing support using Ray and Dask.</li> <li>Comprehensive documentation and examples.</li> <li>Unit and integration tests for the library.</li> <li>Pre-commit hooks, GitHub Actions, and other CI/CD configurations.</li> </ul>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This guide will walk you through the process of installing and using the PolyGoneNMS library. By the end, you will have a basic understanding of how to apply Non-Maximum Suppression on polygon data using various methods and settings.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>You can install the PolyGoneNMS library using <code>pip</code>. Run the following command in your terminal or command prompt:</p> <pre><code>pip install polygone-nms\n</code></pre>"},{"location":"quickstart/#basic-usage","title":"Basic Usage","text":"<p>To use the PolyGoneNMS library, you'll need to import the polygone_nms function:</p> <pre><code>from polygone_nms import polygone_nms\n</code></pre> <p>Next, prepare your input data as a NumPy or PyTorch array in the following format: <code>[x1, y1, x2, y2, ..., class, confidence]</code>. Here's a sample input data:</p> <pre><code>import numpy as np\n\ndata = np.array([\n    [0, 0, 1, 1, 0, 1, 1, 1, 0, 0.9],\n    [1, 1, 2, 2, 1, 1, 2, 2, 0, 0.8],\n    [2, 2, 3, 3, 2, 2, 3, 3, 1, 0.7],\n])\n</code></pre> <p>Now you can apply the <code>polygone_nms</code> function on your input data:</p> <pre><code>result = polygone_nms(data)\n</code></pre> <p>The <code>result</code> variable will contain the filtered polygons after applying the Non-Maximum Suppression.</p>"},{"location":"quickstart/#customizing-polygonenms","title":"Customizing PolyGoneNMS","text":"<p>PolyGoneNMS allows you to customize its behavior using various parameters. Here's an example of how to use Soft NMS with the Dice coefficient:</p> <pre><code>result = polygone_nms(\n    data,\n    nms_method=\"Soft\",\n    intersection_method=\"Dice\",\n)\n</code></pre> <p>You can also enable distributed processing using Ray or Dask:</p> <pre><code>result = polygone_nms(\n    data,\n    distributed=\"Ray\",\n)\n</code></pre> <p>For more information on the available parameters and their usage, refer to the API Reference page.</p>"},{"location":"quickstart/#example","title":"Example","text":"<p>Here's a complete example that demonstrates how to use the PolyGoneNMS library:</p> <pre><code>import numpy as np\nfrom polygone_nms import nms\n\n# Sample input data\ndata = np.array([\n    [0, 0, 1, 1, 0, 1, 0, 0, 1, 0.9],\n    [0.5, 0.5, 1.5, 1.5, 0.5, 1.5, 0, 0, 1, 0.8],\n])\n\n# Apply PolyGoneNMS with custom settings\nresult = nms(\n    data,\n    nms_method=\"Soft\",\n    intersection_method=\"Dice\",\n#    distributed=\"Ray\",\n)\n\n# Print the filtered polygons\nprint(data[result])\n</code></pre> <p>This example uses Soft NMS with the Dice coefficient and Ray for distributed processing. The output will be the filtered polygons after applying the Non-Maximum Suppression.</p>"}]}